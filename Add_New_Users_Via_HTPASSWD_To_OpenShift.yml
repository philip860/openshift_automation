---
- hosts: localhost
  gather_facts: false
  vars_files:
    - files/new_users.yml

  vars:
    # Where the HTPasswd Secret lives and which key holds the file
    htpasswd_secret_namespace: "openshift-config"
    htpasswd_secret_name: "htpasswd-secret"   # adjust if yours is different
    htpasswd_key: "htpasswd"

    # Kube auth (uses your existing oc login by default)
    kubeconfig_path: "~/.kube/config"
    validate_certs: false

  module_defaults:
    kubernetes.core.k8s:
      kubeconfig: "{{ kubeconfig_path }}"
      validate_certs: "{{ validate_certs }}"
    kubernetes.core.k8s_info:
      kubeconfig: "{{ kubeconfig_path }}"
      validate_certs: "{{ validate_certs }}"

  tasks:
    - name: Fetch existing htpasswd Secret (if any)
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Secret
        name: "{{ htpasswd_secret_name }}"
        namespace: "{{ htpasswd_secret_namespace }}"
      register: htsec
      failed_when: false

    - name: Backup current htpasswd Secret (if present)
      copy:
        dest: "backup-{{ htpasswd_secret_namespace }}-{{ htpasswd_secret_name }}.json"
        content: "{{ htsec.resources[0] | to_nice_json }}"
        mode: "0600"
      when: (htsec.resources | default([])) | length > 0
      changed_when: false

    - name: Create a local temp htpasswd file
      tempfile:
        state: file
        suffix: ".htpasswd"
      register: tmp_ht
      changed_when: false

    - name: Seed temp htpasswd with current content (if secret exists)
      copy:
        dest: "{{ tmp_ht.path }}"
        mode: "0600"
        content: >-
          {{
            (htsec.resources | default([])) | length > 0 and
            (htsec.resources[0].data is defined) and
            (htsec.resources[0].data[htpasswd_key] is defined)
            | ternary(htsec.resources[0].data[htpasswd_key] | b64decode, '')
          }}
      changed_when: false

    - name: Ensure users exist in local htpasswd (bcrypt)
      community.general.htpasswd:
        path: "{{ tmp_ht.path }}"
        name: "{{ item.name }}"
        password: "{{ item.password }}"
        crypt_scheme: "bcrypt"
        mode: "0600"
        state: present
      loop: "{{ users }}"
      loop_control:
        label: "{{ item.name }}"

    - name: Read resulting htpasswd file (base64 ready for Secret.data)
      slurp:
        src: "{{ tmp_ht.path }}"
      register: ht_b64

    - name: Create/Update htpasswd Secret with new content
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ htpasswd_secret_name }}"
            namespace: "{{ htpasswd_secret_namespace }}"
          type: Opaque
          data:
            "{{ htpasswd_key }}": "{{ ht_b64.content }}"
      register: secret_apply

    - name: Tell operator what changed
      debug:
        msg: >-
          Updated Secret {{ htpasswd_secret_namespace }}/{{ htpasswd_secret_name }}
          with {{ users | length }} user(s). Existing users not in users.yml were preserved.
      when: secret_apply is changed

    # Optional: report which 'User' objects currently exist (informational)
    - name: Check if OpenShift User objects exist (post-login only)
      kubernetes.core.k8s_info:
        api_version: user.openshift.io/v1
        kind: User
        name: "{{ item.name }}"
      loop: "{{ users }}"
      register: user_objs
      failed_when: false
      changed_when: false

    - name: Summary of user objects
      debug:
        msg: >-
          User '{{ users[idx].name }}' {{ (user_objs.results[idx].resources | default([])) | length > 0
          | ternary('exists (has logged in before)','does NOT exist yet (will be created on first login)') }}
      loop: "{{ range(0, users | length) | list }}"
      loop_control:
        index_var: idx
      changed_when: false
