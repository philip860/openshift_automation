---
- hosts: localhost
  gather_facts: false
  vars_files:
    - files/users.yml

  vars:
    preferred_htpasswd_idp: ""
    htpasswd_secret_namespace: "openshift-config"
    htpasswd_key: "htpasswd"

    kubeconfig_path: "~/.kube/config"
    validate_certs: false

  module_defaults:
    kubernetes.core.k8s:
      kubeconfig: "{{ kubeconfig_path }}"
      validate_certs: "{{ validate_certs }}"
    kubernetes.core.k8s_info:
      kubeconfig: "{{ kubeconfig_path }}"
      validate_certs: "{{ validate_certs }}"

  tasks:
    # --- Discover HTPasswd IdP + Secret name
    - name: Get OAuth cluster configuration
      kubernetes.core.k8s_info:
        api_version: config.openshift.io/v1
        kind: OAuth
        name: cluster
      register: oauth_cfg

    - name: Extract HTPasswd identity providers
      set_fact:
        ht_idps_htpasswd: >-
          {{
            (oauth_cfg.resources | default([])) | length > 0
            and (oauth_cfg.resources[0].spec.identityProviders | default([]) | selectattr('type','equalto','HTPasswd') | list)
            or []
          }}

    - name: Fail if no HTPasswd IdP is configured
      fail:
        msg: "No HTPasswd IdP found in OAuth/cluster."
      when: ht_idps_htpasswd | length == 0

    - name: Pick desired HTPasswd IdP (by name, or first found)
      set_fact:
        chosen_idp: >-
          {{
            (preferred_htpasswd_idp | length > 0)
            | ternary(
                (ht_idps_htpasswd | selectattr('name','equalto', preferred_htpasswd_idp) | list | first),
                (ht_idps_htpasswd | first)
              )
          }}

    - name: Determine HTPasswd Secret name from chosen IdP
      set_fact:
        htpasswd_secret_name: "{{ chosen_idp.htpasswd.fileData.name | default('') }}"

    - name: Validate discovered Secret name
      fail:
        msg: "Could not determine Secret name from HTPasswd IdP."
      when: htpasswd_secret_name | length == 0

    - name: Info - Using HTPasswd IdP/Secret
      debug:
        msg: "Using IdP '{{ chosen_idp.name | default('unnamed') }}' with Secret {{ htpasswd_secret_namespace }}/{{ htpasswd_secret_name }} (key='{{ htpasswd_key }}')"

    # --- Read/backup current Secret
    - name: Fetch existing htpasswd Secret (if any)
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Secret
        name: "{{ htpasswd_secret_name }}"
        namespace: "{{ htpasswd_secret_namespace }}"
      register: htsec
      failed_when: false

    - name: Backup current htpasswd Secret (if present)
      copy:
        dest: "backup-{{ htpasswd_secret_namespace }}-{{ htpasswd_secret_name }}.json"
        content: "{{ htsec.resources[0] | to_nice_json }}"
        mode: "0600"
      when: (htsec.resources | default([])) | length > 0
      changed_when: false

    # --- Build new htpasswd locally (works even in --check)
    - name: Create a local temp htpasswd file
      tempfile:
        state: file
        suffix: ".htpasswd"
      register: htpasswd_tmpfile
      changed_when: false
      check_mode: no

    - name: Seed temp htpasswd with current content (if secret exists)
      copy:
        dest: "{{ htpasswd_tmpfile.path }}"
        mode: "0600"
        content: >-
          {{
            (htsec.resources | default([])) | length > 0
            and (htsec.resources[0].data is defined)
            and (htsec.resources[0].data[htpasswd_key] is defined)
            | ternary(htsec.resources[0].data[htpasswd_key] | b64decode, '')
          }}
      changed_when: false
      check_mode: no

    - name: Ensure users exist in local htpasswd (bcrypt)
      community.general.htpasswd:
        path: "{{ htpasswd_tmpfile.path }}"
        name: "{{ item.name }}"
        password: "{{ item.password }}"
        crypt_scheme: "bcrypt"
        mode: "0600"
        state: present
      loop: "{{ users }}"
      loop_control:
        label: "{{ item.name }}"
      check_mode: no

    - name: Read resulting htpasswd file (base64 for Secret.data)
      slurp:
        src: "{{ htpasswd_tmpfile.path }}"
      register: ht_b64
      check_mode: no

    - name: Build Secret data map with resolved key
      set_fact:
        htpasswd_data: "{{ { (htpasswd_key): ht_b64.content } }}"

    # --- Dry-run message for --check
    - name: WOULD update htpasswd Secret (check mode)
      debug:
        msg: >-
          WOULD update Secret {{ htpasswd_secret_namespace }}/{{ htpasswd_secret_name }}
          (data keys: {{ htpasswd_data.keys() | list }}) with {{ users | length }} user(s).
          Existing entries would be preserved.
      when: ansible_check_mode

    # --- Update Secret (real run)
    - name: Create/Update htpasswd Secret with merged content (real run)
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ htpasswd_secret_name }}"
            namespace: "{{ htpasswd_secret_namespace }}"
          type: Opaque
          data: "{{ htpasswd_data }}"
      register: secret_apply
      when: not ansible_check_mode

    - name: Tell operator what changed
      debug:
        msg: "Updated Secret {{ htpasswd_secret_namespace }}/{{ htpasswd_secret_name }} with {{ users | length }} user(s)."
      when:
        - not ansible_check_mode
        - secret_apply is changed

    # --- NEW: Restart oauth-openshift to reload htpasswd
    - name: Trigger oauth-openshift rollout (force reread of Secret)
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: oauth-openshift
            namespace: openshift-authentication
          spec:
            template:
              metadata:
                annotations:
                  auth.openshift.io/restartedAt: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"
      when: not ansible_check_mode

    - name: Wait for oauth-openshift to become Available
      kubernetes.core.k8s_info:
        api_version: apps/v1
        kind: Deployment
        name: oauth-openshift
        namespace: openshift-authentication
      register: dep_oauth
      until: >
        (dep_oauth.resources | length) > 0 and
        (
          (
            dep_oauth.resources[0].status.availableReplicas | default(0)
          ) | int
        ) >= 1
      retries: 30
      delay: 5
      when: not ansible_check_mode

    # --- Optional: show whether OpenShift User objects exist
    - name: Check if OpenShift User objects exist
      kubernetes.core.k8s_info:
        api_version: user.openshift.io/v1
        kind: User
        name: "{{ item.name }}"
      loop: "{{ users }}"
      register: user_objs
      failed_when: false
      changed_when: false

    - name: Summary of user objects
      debug:
        msg: >-
          User '{{ item.name }}'
          {{
            (
              (user_objs.results[i].resources | default([]) | length) | int > 0
            )
            | ternary('exists (has logged in before)',
                      'does NOT exist yet (will be created on first login)')
          }}
      loop: "{{ users }}"
      loop_control:
        index_var: i
        label: "{{ item.name }}"
      changed_when: false
